# -*- coding:utf-8 -*-
import os
import shutil
import struct
import random
import time

INFO = 0
DEBUG = 1
ERROR = 2


_DEBUG = False


class AGRandom:
    def __init__(self, seed=None):
        if seed is None:
            seed = int(self.getSeed())

        self.agRand = random.seed(seed)

    def getSeed(self):
        t = time.gmtime()
        return "%04d%02d%02d" % (t.tm_year, t.tm_mon, t.tm_mday)

    def getRand(self, _range):
        min = _range[0]
        max = _range[1]
        return random.randint(min, max)

    def probability(self, percent=10):
        """
        랜덤 확률을 통해 난독화 적용
        :param percent:
        :return:
        """
        value = random.randint(0, 99)

        if value < percent:
            return True
        else:
            return False


def reshape(name):
    rename = name.replace(".", "/")
    rename = "L" + rename
    if name[-1] != "." and name[-1] != "*":
        rename += ";"

    return rename


def genName(strSize=25):
    """
    문자열 인코딩 문제로 에러 발생할 수 있으므로 변경함 
    """
    strings = ["1", "i", "l", "I", "j"]
    size = agRand.getRand([strSize-10, strSize])    # random.randint(strSize-10, strSize)
    name = ""
    for i in range(size):
        idx = agRand.getRand([0, 4])     # random.randint(0, 4)
        if i == 0 and idx == 0:
            idx = 1

        name += strings[idx]
        
    return name


def make_file(filename):
    try:
        import codecs
        filename = filename
        dirpath = os.path.dirname(filename)
        if not os.path.exists(dirpath):
            os.makedirs(dirpath)
        fp = codecs.open(filename, "wb")

        return fp

    except:
        import traceback
        print traceback.format_exc()
        return False


def DPRINT(_type, text):
    """
    로컬 빌드용
    :param _type:
    :param text:
    :return:
    """
    if _DEBUG is False:
        return
    try:
        print "[%s] %s" % (_type, text.encode("utf-8"))
    except IOError:
        None
    except:
        None


class FileHandle:
    """
        custom file handle
    """

    def __init__(self, mm):
        self.mm = mm
        self.off = 0

    def getSize(self):
        return self.mm.size()

    def close(self):
        self.mm.close()

    def get_string(self):
        null_pos = self.mm.find("\x00", self.off)
        val = self.mm[self.off:null_pos]
        return val

    def read(self, size):
        val = self.mm[self.off:self.off + size]
        self.off += size
        return val

    def write(self, data):
        self.mm[self.off:self.off + len(data)] = data
        self.off += len(data)

    def seek(self, offset):
        self.off = offset

    def tell(self):
        return self.off

    def write_dword(self, value, pos=None):
        val = struct.pack('<L', value)
        if pos != None:
            self.mm[pos:pos + 4] = val
        else:
            self.mm[self.off:self.off + 4] = val
            self.off += 4

    def write_word(self, value):
        val = struct.pack('<H', value)
        self.mm[self.off:self.off + 2] = val
        self.off += 2

    def write_byte(self, value):
        self.mm[self.off] = chr(value)
        self.off += 1

    def read_dword(self):
        val = struct.unpack('<L', self.mm[self.off:self.off + 4])[0]
        self.off += 4
        return val

    def read_word(self):
        val = struct.unpack('<H', self.mm[self.off:self.off + 2])[0]
        self.off += 2
        return val

    def read_byte(self):
        val = ord(self.mm[self.off])
        self.off += 1
        return val

    def read_uleb128(self):
        result = 0
        shift = 0
        idx = 0
        while 1:
            byte = ord(self.mm[self.off])
            result |= ((byte & 0x7f) << shift)
            if (byte & 0x80) == 0:
                self.off += 1
                break
            else:
                shift += 7
            self.off += 1

        return result

    # ref : https://github.com/Polidea/ios-class-guard/blob/master/Source/ULEB128.m
    def read_sleb128(self):
        bit = 0
        result = 0
        byte = 0
        for i in xrange(0, 5):
            byte = ord(self.mm[self.off + i])
            result |= ((byte & 0x7F) << bit)
            bit += 7
            if (byte & 0x80) == 0:
                break

        if (byte & 0x40) != 0:
            result |= ((-1) << bit)

        self.off += (i + 1)
        return result

        '''
        value = 0

        mask = [0xffffff80, 0xffffc000, 0xffe00000, 0xf0000000, 0]
        bitmask = [0x40, 0x40, 0x40, 0x40, 0x8]
        value = 0
        for i in xrange(0, 5):
            tmp = ord(self.mm[self.off + i]) & 0x7f
            value = tmp << (i * 7) | value
            if (ord(self.mm[self.off + i]) & 0x80) != 0x80:
                if bitmask[i] & tmp:
                    value |= mask[i]
                break
        if i == 4 and (tmp & 0xf0) != 0:
            print "parse a error uleb128 number"
            return -1
        buffer = struct.pack("I", value)
        value, = struct.unpack("i", buffer)
        self.off += (i+1)
        return value
        '''
    def write_uleb128(self, data):
        idx = 0
        result = ""

        while 1:
            if data == 0:
                break
            byte = data & 0x7f
            data >>= 7

            if data != 0:
                byte |= 0x80

            result += chr(byte)

        self.write(result)


# ---------------------------------------------------------------------
# ReadValue : 특수 문자로 숫자 포맷 처리
#
# 사용예 : 포맷 글자 하나당 니블로 처리
# buf = '\xff\xbb\x11\xcc\x22\x33\x44'
# ReadValue(buf, 'A,+B,CC,+DDDD')
#
# 결과 :
# {'A': 15, 'B': -1, 'C': 187, 'D': -13295}
# ---------------------------------------------------------------------
def ReadValue(buf, format_str):
    ret = {}

    # 입력 버퍼 문자열 변환 작업
    buf_str = ''
    # for s in buf:
    #    buf_str += '%02X' % ord(s)

    # print buf_str

    # 포맷 처리
    format_list = format_str.split(',')
    off = 0
    is_4bit = False
    for i in range(len(format_list)):
        format_name = format_list[i]

        signed = 0
        if format_name[0] == '+':  # 부호 처리
            signed = 1
            format_name = format_name[1:]

        size = len(format_name) / 2

        if size == 0 or size == 1:
            if signed:
                fmt = "<b"
            else:
                fmt = "<B"

        elif size == 2:
            if signed:
                fmt = "<h"
            else:
                fmt = "<H"
        elif size == 4:
            if signed:
                fmt = "<l"
            else:
                fmt = "<L"
        elif size == 8:
            if signed:
                fmt = "<q"
            else:
                fmt = "<Q"
        else:
            fmt = None

        if fmt is None:
            print "[!] ERROR"

        if size == 0:
            data = struct.unpack(fmt, buf[off:off + 1])[0]
            if is_4bit is False:
                data = (data >> 4) & 0xf
                is_4bit = True
            else:
                data = data & 0xf
                is_4bit = False
                off += 1
            if signed:
                if 7 < data:
                    data = data - 0x10
        else:
            data = struct.unpack(fmt, buf[off:off + size])[0]
            off += size

        val_str = format_name[0]  # 변수명

        # print format_name, signed
        ret[val_str] = data

    return ret


def ReadValue2(buf, format_str):
    ret = {}

    # 입력 버퍼 문자열 변환 작업
    buf_str = ''
    for s in buf:
        buf_str += '%02X' % ord(s)

    # print buf_str

    # 포맷 처리
    format_list = format_str.split(',')

    for i in range(len(format_list)):
        format_name = format_list[i]

        signed = 0

        if format_name[0] == '+':  # 부호 처리
            signed = 1
            format_name = format_name[1:]

        val_str = format_name[0]  # 변수명

        # 버퍼에서 값 읽기
        num_nib = len(format_name)
        b_str = buf_str[0:num_nib]

        # 숫자로 변환
        num = 0
        j = 0
        while len(b_str) > 0:
            if len(b_str) >= 2:
                val = int(b_str[0:2], 16) << (j * 8)
                num += val
                b_str = b_str[2:]
                j += 1
            else:
                val = int(b_str[0], 16) << (j * 8)
                num += val
                break

        if signed == 1:
            sig = 1
            sig <<= (num_nib * 4) - 1

            and_process = 1
            and_process <<= (num_nib * 4)
            and_process -= 1

            if num & sig == sig:  # 2의 보수 처리
                num -= 1  # 우선 1을 뺀다
                num = ~num  # 1의 보수를 취한다
                num &= and_process  #
                num *= -1  # -1을 곱한다.

        buf_str = buf_str[num_nib:]

        # print format_name, signed
        ret[val_str] = num

    return ret


def _decode(b):
    # decode arbitrary utf8 codepoints, tolerating surrogate pairs, nonstandard encodings, etc.
    for x in b:
        x = ord(x)
        if x < 128:
            yield x
        else:
            # figure out how many bytes
            extra = 0
            for i in range(6, 0, -1):
                if x & (1<<i):
                    extra += 1
                else:
                    break

            bits = x % (1 << 6-extra)
            for _ in range(extra):
                bits = (bits << 6) ^ (ord(next(b)) & 63)
            yield bits


def _fixPairs(codes):
    # convert surrogate pairs to single code points
    for x in codes:
        if 0xD800 <= x < 0xDC00:
            high = x - 0xD800
            low = next(codes) - 0xDC00
            yield (high << 10) + (low & 1023)
        else:
            yield x


def out(a, _type):

    if _type == "inst":
        return "\u%04x" % a

    if 0x1F < a < 0x7F:
        t = chr(a)
        if t in ['\'', '\"', '\\']:
            t = "\\" + t

        return t
    else:
        if a > 0xFFFF:
            return "\u%x" % a
        else:
            return "\u%04x" % a


def decode(s, _type=None):
    """
    Decodes a bytestring containing modified UTF-8 as defined in section
    4.4.7 of the JVM specification.
    :param s: bytestring to be converted.
    :returns: A unicode representation of the original string.
    """
    try:
        s = bytearray(s)
    except TypeError:

        s = s.encode("utf-8")
        t = []
        for i in s:
            t.append(ord(i))
        s = t


    buff = []
    buffer_append = buff.append
    ix = 0
    while ix < len(s):
        x = s[ix]
        ix += 1

        if x < 0x7F:
            # Just an ASCII character, nothing else to do.
            pass
        elif x >> 6 == 6:
            y = s[ix]
            ix += 1
            x = ((x & 0x1F) << 6) + (y & 0x3F)
        elif x >> 4 == 14:
            y, z = s[ix:ix+2]
            ix += 2
            x = ((x & 0xF) << 12) + ((y & 0x3F) << 6) + (z & 0x3F)
        elif x == 0xED:
            v, w, x, y, z = s[ix:ix+6]
            ix += 5
            x = 0x10000 + (
                ((v & 0x0F) << 16) +
                ((w & 0x3F) << 10) +
                ((y & 0x0F) << 6) +
                (z & 0x3F)
            )
        elif (x & 0xC0) == 0xC0:
            y = s[ix]
            ix += 1
            x = ((x & 0x1F) << 6) + (y & 0x3F)
        # and s[ix] == 0x80:

        buffer_append(x)
    return u''.join(out(b, _type) for b in buff)

