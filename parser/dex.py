# -*- coding:utf-8 -*-

import mmap
import os
import util
from dex_header import *
from dalvik_define import *


def typeStringToSrc(typeString):
    append = ""
    for idx in range(len(typeString)):
        if typeString[idx] == "[":
            append += "[]"

        else:
            typeString = typeString[idx:]
            break

    if typeString == "I":
        return "int" + append
    elif typeString == "Z":
        return "boolean" + append
    elif typeString == "S":
        return "short" + append
    elif typeString == "J":
        return "long" + append
    elif typeString == "F":
        return "float" + append
    elif typeString == "D":
        return "double" + append
    elif typeString == "C":
        return "character" + append
    elif typeString == "B":
        return "byte" + append
    elif typeString == "V":
        return "void"
    else:
        return typeString.replace("/", ".")[1:-1] + append


class DalvikMethod:
    def __init__(self, dex):
        self.obfFlag = False            # 난독화 여부
        self.oString = False            # 문자열 난독화 대상 여부
        self.hcFlag = False             #
        self.inline = False
        self.oID = False
        self.v = False                  # 추가된 메서드 체크 플래그
        self.vId = None                 # 추가 메서드  ID
        self.vName = None               # 추가 메서드 이름
        self.code = None
        self.text = None                #
        self.type = None
        self.methodAnnotations = None   # method annotation
        self.paramAnnotations = None
        self.annotationText = []        # annotation string
        self.nRegisters = None
        self.nParameters = None
        self.payload_table = {}
        self.payload = []
        self.Instructions = []
        self.try_catch = [[], [], []]  # try catch
        self.arrayCount = 0
        self.encStrings = []
        self.label_table = LABEL_TABLE()
        self.try_start = {}
        self.try_end = {}
        self.catch_table = {}
        self.catch_all = {}
        self.handles = []

        self.__dex = dex
        self.__class_idx = None
        self.__proto_idx = None
        self.__name_idx = None
        self.__method_idx = None
        self.__access_flags = None
        self.__code_item = None
        self.__obfName = None
        self.__origName = None
        self.__proto = None

    def __setTarget(self):
        name = self.getFullName()

        if self.__dex.filter.idInfo.excludeMethod is not None:
            for pattern in self.__dex.filter.idInfo.excludeMethod:
                if pattern.search(name) is not None:
                    self.oID = False
                    break

    def insertInst(self, pos, ins):
        self.Instructions.insert(pos, ins)

    def setClass(self, classId):
        self.__class_idx = classId

    def setInitValue(self, methodItem):
        """

        :param methodItem:
        :return:
        """
        self.__class_idx = methodItem.class_idx
        self.__proto_idx = methodItem.proto_idx
        self.__name_idx = methodItem.name_idx

    def setObfuscate(self, data):
        """

        :param data:
        :return:
        """
        self.__obfName = data

    def getId(self):
        return self.__method_idx

    def getFlag(self):
        return self.__access_flags

    def getName(self):
        if self.obfFlag:
            return self.__obfName
        elif self.v:
            return self.vName
        else:
            return self.getOrigName()

    def getOrigName(self):
        if self.v:
            return self.vName
        if self.__origName is None:
            self.__origName = self.__dex.getString(self.__name_idx)
        return self.__origName

    def getClass(self, _type=None):
        # return self.__dex.getString(self.__dex.getTypeId(self.__class_idx))
        if _type == "id":
            return self.__class_idx
        else:
            return self.__dex.typeToString(self.__class_idx)

    def setFlag(self, _str):
        self.__access_flags = _str

    def setProto(self, arg, ret):
        self.__proto = [ret, arg]

    def getProto(self):
        if self.__proto is not None:
            return self.__proto[0], self.__proto[1]
        if self.v:
            return "V", ""
        else:
            return self.__dex.protoToString(self.__proto_idx)

    def getParam(self, _type=None):
        if self.__proto is not None:
            data = self.__proto
        else:
            if self.__proto_idx is None:
                return ""
            data = self.__dex.protoToData(self.__proto_idx)

        if _type is None:
            return data[1]
        else:
            result = ""
            for d in data[1]:
                result += typeStringToSrc(d)
                result += ","

            if result != "" and result[-1] == ',':
                return result[:-1]
            else:
                return result

    def getReturnType(self, _type=None):
        if self.__proto is not None:
            data = self.__proto
        else:
            if self.__proto_idx is None:
                None
            data = self.__dex.protoToData(self.__proto_idx)
        if _type is None:
            return data[0]
        else:
            return typeStringToSrc(data[0])

    def getFullName(self, _type="class"):
        className = self.getClass()
        methodName = self.getName()
        ret, param = self.getProto()

        if _type == "method":
            methodString = "%s->%s(%s)%s" % (className, methodName, param, ret)
            return methodString
        elif _type == "class":
            methodString = "%s(%s)%s" % (methodName, param, ret)
            return methodString
        else:
            return className, ret, param, methodName

    def getOrigFullName(self, _type="class"):
        """
        :param _type:
        :return:
        """
        if self.v:
            return self.vName
        className = self.__dex.typeToString(self.__class_idx, True)
        ret, param = self.__dex.protoToString(self.__proto_idx, True)
        methodName = self.getOrigName()

        if _type == "method":
            methodString = "%s->%s(%s)%s" % (className, methodName, param, ret)
            return methodString
        elif _type == "class":
            methodString = "%s(%s)%s" % (methodName, param, ret)
            return methodString
        else:
            return className, ret, param, methodName

    def analysis(self, eMethod, oString=False):
        self.__method_idx = eMethod.method_idx
        self.__access_flags = flags2string(eMethod.access_flags)
        self.__code_item = eMethod.code_item
        if oString is True:
            self.oString = True

    def annotationToString(self, element, depth=0):
        return self.__dex.annotation_to_string(element, depth)

    def getCodeItem(self):
        return self.__code_item

    def customMethodInit(self, classId):
        self.__access_flags = "public static constructor"
        self.__class_idx = classId
        self.nRegisters = 0

    def setAnnoText(self):
        self.annotationText = []
        # TODO PARAM 코드 정리 필요
        param_pos = 0
        param_idx = 0
        methodIdx = self.getId()

        if self.paramAnnotations is not None and methodIdx in self.paramAnnotations:
            for param_annotation in self.paramAnnotations[methodIdx].items:
                params = self.getParam()
                if len(param_annotation.items) == 0:
                    if params[param_pos] == "D" or params[param_pos] == "J":
                        param_idx += 1
                    param_pos += 1
                    param_idx += 1
                    continue
                if "static" in self.getFlag():
                    tmp = "    .param p%d   # %s\n" % (param_idx, params[param_pos])
                else:
                    tmp = "    .param p%d   # %s\n" % (param_idx + 1, params[param_pos])

                for _param_annotation in param_annotation.items:
                    tmp += self.annotationToString(_param_annotation, 2)
                tmp += "    .end param\n"
                self.annotationText.append(tmp)
                if params[param_pos] == "D" or params[param_pos] == "J":
                    param_idx += 1
                param_pos += 1
                param_idx += 1

        if self.methodAnnotations is not None and methodIdx in self.methodAnnotations:
            for annotation in self.methodAnnotations[methodIdx].items:
                self.annotationText.append(self.annotationToString(annotation, 1))


class DalvikField:
    def __init__(self, dex):
        # public field
        self.className = None
        self.protoName = None
        self.name = None
        self.obfFlag = False
        self.annotation = None
        self.value = None
        self.vIdx = None
        self.text = None
        self.type = None
        self.oString = False    # 문자열 난독화 대상 여부
        self.oID = False
        self.handles = []

        # private field
        self.__dex = dex
        self.__class_idx = None
        self.__proto_idx = None
        self.__name_idx = None
        self.__fieldIdx = None
        self.__accessFlag = None
        self.__obfName = None
        self.__origName = None

    def setInitValue(self, fieldItem):
        self.__class_idx = fieldItem.class_idx
        self.__proto_idx = fieldItem.proto_idx
        self.__name_idx = fieldItem.name_idx

    def getFlag(self):
        return self.__accessFlag

    def getId(self):
        return self.__fieldIdx

    def setObfuscate(self, data):
        # self.__dex.setObfuscate(self.__name_idx, data)
        self.__obfName = data

    def getName(self):
        if self.obfFlag:     #
            return self.__obfName
        else:
            # 상속 관계에서 필드명 처리를 위한 로직
            fieldName = self.getOrigName()
            return fieldName

    def getOrigName(self):
        if self.__origName is None:
            self.__origName = self.__dex.getString(self.__name_idx)
        return self.__origName

    def getClass(self, _type=None):
        # return self.__dex.getClass(self.__class_idx).getFullName()      # 클래스 이름
        if _type == "id":
            return self.__class_idx
        else:
            return self.__dex.typeToString(self.__class_idx, True)

    def getProto(self, _type=None):
        typeString = self.__dex.typeToString(self.__proto_idx)  # self.__dex.getString(self.__dex.getTypeId(self.__proto_idx))
        if _type == "src":
            return typeStringToSrc(typeString)
        else:
            return typeString

    def getFullName(self, _type="class"):
        """

        :param _type:
        :return:
        """
        className = self.getClass()
        protoName = self.getProto()
        name = self.getName()

        if _type == "class":
            fieldString = "%s:%s" % (name, protoName)
            return fieldString

        elif _type == "method":
            fieldString = "%s->%s:%s" % (className, name, protoName)
            return fieldString

        return False

    def getOrigFullName(self, _type="class"):
        """

        :param _type:
        :return:
        """
        className = self.__dex.typeToString(self.__class_idx, True)
        protoName = self.__dex.typeToString(self.__proto_idx, True)
        name = self.getOrigName()

        if _type == "class":
            fieldString = "%s:%s" % (name, protoName)
            return fieldString

        elif _type == "method":
            fieldString = "%s->%s:%s" % (className, name, protoName)
            return fieldString

        return False

    def analysis(self, eField, oString=False):
        self.__fieldIdx = eField[0]
        self.__accessFlag = flags2string(eField[1])
        if oString is True:
            self.oString = True

    def getValue(self):
        if self.value is not None and self.vIdx < len(self.value):
            eValue = self.value[self.vIdx]
            fieldValue = self.__dex.annotatioValueToString(eValue)
            return fieldValue

    def annotationToString(self, element, depth=0):
        return self.__dex.annotation_to_string(element, depth)

    def setText(self):

        fieldValue = self.getValue()
        fieldIdx = self.getId()

        # field annotation이 존재하는 경우
        if self.annotation is not None and fieldIdx in self.annotation:
            # print self.getFlag(), self.getFullName("class"), fieldValue
            # 필드 값이 있는 경우
            if fieldValue is not None and fieldValue != "null" and self.type == "static":
                tmp = ".field %s %s = %s\n" % (self.getFlag(), self.getFullName("class"), fieldValue)
            else:
                tmp = ".field %s %s\n" % (self.getFlag(), self.getFullName("class"))
            # annotation 추가
            for field_annotation in self.annotation[fieldIdx].items:
                tmp += self.annotationToString(field_annotation, 1)
            tmp += ".end field"
            self.text = tmp

        else:
            # 필드 값이 있는 경우
            if fieldValue is not None and fieldValue != "null" and self.type == "static":
                self.text = ".field %s %s = %s" % (self.getFlag(), self.getFullName("class"), fieldValue)
            else:
                self.text = ".field %s %s" % (self.getFlag(), self.getFullName("class"))


class DalvikClass:
    def __init__(self, dex):
        self.obfFlag = False      # 난독화 여부
        self.annotations = None
        self.staticValues = None
        self.classDataItem = None
        self.code = None
        self.oString = False        # 문자열 난독화 대상 여부
        self.oID = False
        self.hInterface = []
        self.superList = []
        self.hSuper = None
        self.__obfName = None

        self.oClass = True
        self.oField = True
        self.oMethod = True

        self.fieldTable = {}
        self.methodTable = {}

        self.fields = []
        self.inheritanceFields = []
        self.inheritanceMethods = []

        self.filter = dex.filter

        # private field
        self.__dex = dex
        self.__package = None
        self.__staticFields = []
        self.__instanceFields = []
        self.__directMethod = []
        self.__virtualMethod = []
        self.__additionMethod = []
        self.__annotations = []
        self.__classIdx = None
        self.__cType = None
        self.__accessFlag = None
        self.__origName = None
        self.classDef = None

    def __fieldAnalysis(self):
        if self.classDataItem is not None:
            # field 정보 수집
            vIdx = 0
            # static field 분석
            for encodedField in self.classDataItem.static_field_list:
                df = self.__dex.getField(encodedField[0])   #
                df.analysis(encodedField)
                self.__staticFields.append(encodedField[0])
                if self.annotations is not None:
                    df.annotation = self.annotations.fields_annotations
                df.vIdx = vIdx
                df.value = self.staticValues
                df.type = "static"
                vIdx += 1
                if self.oID:
                    df.oID = True

            for encodedField in self.classDataItem.instance_field_list:
                df = self.__dex.getField(encodedField[0])  #
                df.analysis(encodedField)
                df.type = "instance"
                self.__instanceFields.append(encodedField[0])
                if self.annotations is not None:
                    df.annotation = self.annotations.fields_annotations
                if self.oID:
                    df.oID = True

    def __methodAnalysis(self):
        if self.classDataItem is not None:
            for methodInfo in self.classDataItem.virtual_method_list:
                dm = self.__dex.getMethod(methodInfo.method_idx)  #
                dm.analysis(methodInfo)
                dm.type = "virtual"
                self.__virtualMethod.append(dm)

                if self.annotations is not None:
                    dm.methodAnnotations = self.annotations.methods_annotations
                    dm.paramAnnotations = self.annotations.parameters_annotations

                if self.oID:
                    dm.oID = True

            for methodInfo in self.classDataItem.direct_method_list:
                dm = self.__dex.getMethod(methodInfo.method_idx)  #
                dm.analysis(methodInfo)
                dm.type = "direct"

                self.__directMethod.append(dm)

                if self.annotations is not None:
                    dm.methodAnnotations = self.annotations.methods_annotations
                    dm.paramAnnotations = self.annotations.parameters_annotations

                if self.oID:
                    dm.oID = True

    def __setTarget(self):
        name = self.getFullName()
        if self.filter.strInfo.includePackage is not None:
            for pattern in self.filter.strInfo.includePackage:
                if pattern.search(name) is not None:
                    self.oString = True
                    break

        if self.filter.idInfo.includePackage is not None:
            # include 먼저 체크
            for pattern in self.filter.idInfo.includePackage:
                if pattern.search(name) is not None:
                    self.oID = True
                    break

        if self.filter.idInfo.excludePackage is not None:
            for pattern in self.filter.idInfo.excludePackage:
                if pattern.search(name) is not None:
                    self.oID = False
                    break

        if name in self.filter.idInfo.includeClass:
            self.oID = True
        if name in self.filter.idInfo.excludeClass:
            self.oID = False

    def setInitValue(self, classDef):
        self.classDef = classDef
        self.__accessFlag = flags2string(classDef.access_flags)

    def getSource(self):
        # 소스 정보
        if self.classDef.source_file_idx < 0xFFFFFF:
            source = self.__dex.getString(self.classDef.source_file_idx)
        else:
            source = ""

        return source

    def getFlag(self):
        return self.__accessFlag

    def analysis(self):
        self.__classIdx = self.classDef.class_idx
        if self.filter is not None:
            self.__setTarget()          # 난독화 여부 분석
        self.__fieldAnalysis()      # 필드 분석
        self.__methodAnalysis()     #

    def getAnnotation(self):
        if self.annotations is not None:
            if self.annotations.class_annotations is not None:
                for annotation in self.annotations.class_annotations.items:
                    self.__annotations.append(self.__dex.annotation_to_string(annotation))
        return self.__annotations
                    
    def getAnnoText(self):
        annoText = []
        if self.annotations is not None:
            if self.annotations.class_annotations is not None:
                for annotation in self.annotations.class_annotations.items:
                    annoText.append(self.__dex.annotation_to_string(annotation))
        return annoText

    def getPackage(self):
        if self.__package is None:
            self.getFullName()
        return self.__package

    def isObfuscate(self):
        return self.obfFlag

    def setObfuscate(self, data):
        # if self.__cType is None:
        #     self.getFullName()
        # self.__dex.setObfuscate(self.__cType, data)
        self.__obfName = data

    def createMethod(self, methodName=None):
        """

        :param methodName:
        :return:
        """
        dm = DalvikMethod(self.__dex)
        if methodName is not None:
            dm.vName = methodName
        else:
            dm.vName = util.genName()
        dm.v = True
        id = self.__dex.addMethod(dm)
        dm.vId = id
        dm.customMethodInit(self.__classIdx)
        self.__additionMethod.append(dm)
        return dm

    def insertMethod(self, hMethod):
        if hMethod.type == "virtual":
            self.__virtualMethod.append(hMethod)
        elif hMethod.type == "direct":
            self.__directMethod.append(hMethod)
        else:
            None

    def delMethod(self, method):

        if method in self.__additionMethod:
            self.__additionMethod.remove(method)
            if method.vId is not None:
                self.__dex.delMethod(method.vId)

        elif method in self.__virtualMethod:
            self.__virtualMethod.remove(method)

        elif method in self.__directMethod:
            self.__directMethod.remove(method)

    def getId(self):
        return self.__classIdx

    def getName(self):
        name = self.getFullName()
        return name.split("/")[-1].replace(";", "")

    def getFullName(self):
        if self.obfFlag:
            return self.__obfName
        else:
            return self.getOrigName()

    def getOrigName(self):
        """

        :return:
        """
        if self.__origName is None:
            self.__cType = self.__dex.getTypeId(self.__classIdx)
            self.__origName = self.__dex.getString(self.__cType)
            self.__package = "/".join(self.__origName.split("/")[:-1])  # 클래스 패키지
        return self.__origName

    def getOrigFullName(self):
        """

        :return:
        """
        if self.__origName is None:
            self.__cType = self.__dex.getTypeId(self.__classIdx)
            self.__origName = self.__dex.getString(self.__cType)
            self.__package = "/".join(self.__origName.split("/")[:-1])  # 클래스 패키지
        return self.__origName

    def getSuperClass(self, _type=None):
        """

        :return:
        """
        if _type == "id":
            return self.classDef.superclass_idx
        else:
            return self.__dex.typeToString(self.classDef.superclass_idx)

    def getInterface(self, _type="name"):
        """

        :return:
        """
        implement = []
        if self.classDef.interfaces_off != 0:
            off = self.classDef.interfaces_off
            size = self.__dex.getDword(off)
            off += 4
            for i in range(size):
                classId = self.__dex.getWord(off + (i * 2))
                t = self.__dex.getTypeId(classId)
                if _type == "name":
                    implement.append(self.__dex.getString(t))
                elif _type == "id":
                    implement.append(classId)
        return implement

    def getFieldList(self, inheritance=None):
        if inheritance is None:
            return self.__staticFields + self.__instanceFields
        else:
            return self.__staticFields + self.__instanceFields + self.inheritanceFields

    def getField(self, fieldId):
        return self.__dex.getField(fieldId)

    def getMethod(self, methodId):
        return self.__dex.getMethod(methodId)

    def getMethodList(self, inheritance=None):

        if inheritance is None:
            return self.__virtualMethod + self.__directMethod + self.__additionMethod
        else:
            return self.__virtualMethod + self.__directMethod + self.__additionMethod + self.inheritanceMethods

    def getDirectMethods(self):
        return self.__directMethod

    def getVirtualMethods(self):
        return self.__virtualMethod

    def getInstanceFields(self):
        return self.__instanceFields

    def getAdditionMethods(self):
        return self.__additionMethod

    def getStaticFields(self):
        return self.__staticFields

    def findField(self, name):
        for fieldId in self.getFieldList():
            hField = self.getField(fieldId)

            if name == hField.getOrigName():
                return hField
            if name == hField.getName():
                return hField
        return False

    def findMethod(self, name, _type="method"):
        for hMethod in self.getMethodList():
            # hMethod = self.getMethod(methodId)

            if _type == "class":
                if name == hMethod.getOrigFullName("class"):
                    return hMethod
            else:
                if name == hMethod.getOrigFullName("method"):
                    return hMethod
        return False


    def setInfo(self, classId, name):
        self.__classIdx = classId
        self.obfFlag = True
        self.__obfName = name


class DEX:
    """
    DEX class
    """
    def __init__(self, mm, filename, filter=None):
        """
        초기화 함수
        :param mm:
        :param filename:
        """
        self.filter = filter
        self.dataOffset = {}

        # self.obfFlag = False    # 식별자 난독화 완료 플래그 (난독화 진행중 난독화 된 식별자 명을 가져다 쓸수 있으므로)
        # private fields
        self.__fp = util.FileHandle(mm)
        self.__dexFilename = filename   # 파일명
        self.__classTable = {}          # 클래스 핸들 테이블
        self.__methodTable = {}         # 메서드 핸들 테이블
        self.__fieldTable = {}          # 필드 핸들 테이블 
        self.__target = None
        self.__stringTable = []         # 문자열 리스트 
        self.__protoList = []           # proto 리스트 
        self.__typeList = []            # 타입 리스트
        self.__mapItemList = []
        self.__obfTable = {}
        self.__classNameTable = {}

        self.__dmp_filename = self.__dexFilename + ".dmp"
        self.__dmp_fp = open(self.__dmp_filename, "wb")
        self.mm = mmap.mmap(-1, self.__fp.getSize())
        self.__dexParse()
        self.__analysis()
        self.target = False
        self._type = None   # loader dex 인지 앱 dex 인지 구분하는 플래그

    def writeDmpFile(self, offset, size, value):
        self.mm.seek(offset)
        self.mm.write(value * size)

    def getDword(self, off):
        self.__fp.seek(off)
        return self.__fp.read_dword()

    def getWord(self, off):
        self.__fp.seek(off)
        return self.__fp.read_word()

    def delMethod(self, methodId):
        del self.__methodTable[methodId]

    def addMethod(self, dm):
        """
        메서드 추가
        :param dm:
        :return:
        """
        methodId = len(self.__methodTable.keys())
        self.__methodTable[methodId] = dm
        return methodId

    def __dexParse(self):
        """
        dex parser
        :return:
        """
        # dexHeader 파싱
        dexHeader = DexHeader(self.__fp)
        self.dataOffset["header"] = {"offset": 0, "size": dexHeader.header_size}
        self.dataOffset["string_ids"] = {"offset": dexHeader.string_ids_off, "size": dexHeader.string_ids_size * 4}
        self.dataOffset["string_items"] = {"offset": 0, "size": 0}
        self.dataOffset["type_ids"] = {"offset": dexHeader.type_ids_off, "size": dexHeader.type_ids_size * 4}
        self.dataOffset["method_ids"] = {"offset": dexHeader.method_ids_off, "size": dexHeader.method_ids_size * 8}
        self.dataOffset["field_ids"] = {"offset": dexHeader.field_ids_off, "size": dexHeader.field_ids_size * 8}
        self.dataOffset["proto_ids"] = {"offset": dexHeader.proto_ids_off, "size": dexHeader.proto_ids_size * 12}
        self.dataOffset["proto_param_item"] = {"offset": 0, "size": 0}
        self.dataOffset["class_defs"] = {"offset": dexHeader.class_defs_off, "size": dexHeader.class_defs_size * 32}
        self.dataOffset["class_data"] = {"offset": 0, "size": 0}
        self.dataOffset["type_item_list"] = {"offset": 0, "size": 0}
        self.dataOffset["code_item"] = {"offset": 0, "size": 0}
        self.dataOffset["annotation_item"] = {"offset": 0, "size": 0}
        self.dataOffset["dex_map_list"] = {"offset": dexHeader.map_off, "size": 0}

        # 문자열 정보 리스트에 추가
        for idx in range(dexHeader.string_ids_size):
            # 문자열 ID offset으로 이동
            self.__fp.seek(dexHeader.string_ids_off + (idx * 4))
            # 해당 ID의 문자열 offset 읽어옴
            off = self.__fp.read_dword()
            self.__fp.seek(off)
            if idx == 0:
                self.dataOffset["string_items"]["offset"] = off

            str_size = self.__fp.read_uleb128()   # !!!!! <- 지우면 안됨!!!!
            _str = self.__fp.get_string()
            self.__stringTable.append(_str)

        self.dataOffset["string_items"]["size"] = off + len(_str) + 1 - self.dataOffset["string_items"]["offset"]

        # 필드 정보 리스트에 추가
        self.__fp.seek(dexHeader.field_ids_off)
        for idx in range(dexHeader.field_ids_size):
            f = FieldItem(self.__fp)
            df = DalvikField(self)
            df.setInitValue(f)
            self.__fieldTable[idx] = df

        # 프로토타입 정보 추가
        self.__fp.seek(dexHeader.proto_ids_off)
        proto_param_off = 0xfffffff
        proto_param_off_list = []
        proto_param_size = 0
        for idx in range(dexHeader.proto_ids_size):
            p = ProtoItem(self.__fp)
            self.__protoList.append(p)
            if p.parameters_off != 0:
                if p.parameters_off < proto_param_off:
                    proto_param_off = p.parameters_off
                if p.parameters_off not in proto_param_off_list:
                    tempOff = self.__fp.tell()
                    self.__fp.seek(p.parameters_off)
                    size = self.__fp.read_dword()
                    self.__fp.seek(tempOff)
                    if size != 0:
                        if (p.parameters_off, (size * 2)) not in proto_param_off_list:
                            proto_param_off_list.append((p.parameters_off, (size * 2 + 4)))

        self.dataOffset["proto_param_item"] = proto_param_off_list

        # 타입 정보 추가
        self.__fp.seek(dexHeader.type_ids_off)
        for idx in range(dexHeader.type_ids_size):
            self.__typeList.append(self.__fp.read_dword())

        # Method 리스트 추가
        self.__fp.seek(dexHeader.method_ids_off)
        for idx in range(dexHeader.method_ids_size):

            mItem = MethodItem(self.__fp)
            dm = DalvikMethod(self)
            dm.setInitValue(mItem)
            self.__methodTable[idx] = dm

        self.__fp.seek(dexHeader.class_defs_off)

        # class 정보 리스트에 추가
        for idx in range(dexHeader.class_defs_size):
            c = ClassDef(self.__fp)
            dc = DalvikClass(self)
            dc.setInitValue(c)
            self.__classTable[c.class_idx] = dc


        # 맵 정보 추가
        self.__fp.seek(dexHeader.map_off)
        mapSize = self.__fp.read_dword()
        self.dataOffset["dex_map_list"]["size"] = mapSize * 0xC + 4
        for idx in range(mapSize):
            self.__mapItemList.append(MapItem(self.__fp))

        return None


    def __analysis(self):
        """
        분석 (클래스 핸들 등 분석)
        :return:
        """
        anno_small = 0xffffffff
        method_item_small = 0xffffffffff
        class_data_list = []
        interface_list = []
        idx = 0
        for classId in self.__classTable:
            dc = self.__classTable[classId]
            if dc.classDef.interfaces_off != 0:
                self.__fp.seek(dc.classDef.interfaces_off)
                size = self.__fp.read_dword()
                if (dc.classDef.interfaces_off, (size * 2) + 4) not in interface_list:
                    interface_list.append((dc.classDef.interfaces_off, (size * 2) + 4))

            if dc.classDef.class_data_off != 0:
                self.__fp.seek(dc.classDef.class_data_off)
                dc.classDataItem = ClassData(self.__fp)
                class_data_list.append((dc.classDataItem.start, dc.classDataItem.size))
                for i in dc.classDataItem.code_item_list:
                    self.writeDmpFile(i[0], i[1], "\x72")

            if dc.classDef.annotations_off != 0:
                self.__fp.seek(dc.classDef.annotations_off)
                dc.annotations = Annotations(self.__fp)
                self.writeDmpFile(dc.annotations.start, dc.annotations.size, "\x73")
                for i in dc.annotations.anno_item_list:
                    self.writeDmpFile(i[0], i[1], "\x73")

            if dc.classDef.static_values_off != 0:
                self.__fp.seek(dc.classDef.static_values_off)
                valueTable = []
                start = self.__fp.tell()
                size = self.__fp.read_uleb128()
                for i in range(size):
                    valueTable.append(EncodedValue(self.__fp))

                self.writeDmpFile(start, self.__fp.tell() - start, "\x51")
                dc.staticValues = valueTable

            dc.analysis()
            self.__classNameTable[dc.getFullName()] = dc
            idx += 1

        self.dataOffset["interface_item_list"] =  interface_list
        self.writeDmpFile(self.dataOffset["header"]["offset"], self.dataOffset["header"]["size"], "\x11")
        self.writeDmpFile(self.dataOffset["string_ids"]["offset"], self.dataOffset["string_ids"]["size"], "\x22")
        self.writeDmpFile(self.dataOffset["type_ids"]["offset"], self.dataOffset["type_ids"]["size"], "\x33")
        self.writeDmpFile(self.dataOffset["proto_ids"]["offset"], self.dataOffset["proto_ids"]["size"], "\x44")
        self.writeDmpFile(self.dataOffset["field_ids"]["offset"], self.dataOffset["field_ids"]["size"], "\x55")
        self.writeDmpFile(self.dataOffset["method_ids"]["offset"], self.dataOffset["method_ids"]["size"], "\x66")
        self.writeDmpFile(self.dataOffset["class_defs"]["offset"], self.dataOffset["class_defs"]["size"], "\x77")
        self.writeDmpFile(self.dataOffset["string_items"]["offset"], self.dataOffset["string_items"]["size"], "\x21")

        for i in self.dataOffset["proto_param_item"]:
            self.writeDmpFile(i[0], i[1], "\x41")

        for i in self.dataOffset["interface_item_list"]:
            self.writeDmpFile(i[0], i[1], "\x41")
        for i in class_data_list:
            self.writeDmpFile(i[0], i[1], "\x71")
        self.writeDmpFile(self.dataOffset["dex_map_list"]["offset"], self.dataOffset["dex_map_list"]["size"], "\x88")
        self.mm.seek(0)


        start = self.mm.find("\x41")
        self.mm.seek(0)
        end = self.mm.rfind("\x41")
        self.dataOffset["type_item_list"]["offset"] = start
        self.dataOffset["type_item_list"]["size"] = end - start

        start = self.mm.find("\x71")
        self.mm.seek(0)
        end = self.mm.rfind("\x71")
        self.dataOffset["class_data"]["offset"] = start
        self.dataOffset["class_data"]["size"] = end - start

        start = self.mm.find("\x72")
        self.mm.seek(0)
        end = self.mm.rfind("\x72")
        self.dataOffset["code_item"]["offset"] = start
        self.dataOffset["code_item"]["size"] = end - start

        start = self.mm.find("\x73")
        self.mm.seek(0)
        end = self.mm.rfind("\x73")
        self.dataOffset["annotation_item"]["offset"] = start
        self.dataOffset["annotation_item"]["size"] = end - start


        self.__dmp_fp.write(self.mm)
        self.__dmp_fp.close()

        self.print_parse_info()
        return None

    def print_parse_info(self):
        print "=========================================================="
        print "[*] Filename : %s" % self.__dexFilename
        print "[*] Output : %s" % self.__dmp_filename
        print "==== headers ===="
        print "[+] header(0x11) - offset : %x size : %x" % (self.dataOffset["header"]["offset"], self.dataOffset["header"]["size"])
        print "[+] string_ids(0x22) - offset : %x size : %x" % (self.dataOffset["string_ids"]["offset"], self.dataOffset["string_ids"]["size"])
        print "[+] type_ids(0x33) - offset : %x size : %x" % (self.dataOffset["type_ids"]["offset"], self.dataOffset["type_ids"]["size"])
        print "[+] proto_ids(0x44) - offset : %x size : %x" % (self.dataOffset["proto_ids"]["offset"], self.dataOffset["proto_ids"]["size"])
        print "[+] field_ids(0x55) - offset : %x size : %x" % (self.dataOffset["field_ids"]["offset"], self.dataOffset["field_ids"]["size"])
        print "[+] method_ids(0x66) - offset : %x size : %x" % (self.dataOffset["method_ids"]["offset"], self.dataOffset["method_ids"]["size"])
        print "[+] class_defs(0x77) - offset : %x size : %x" % (self.dataOffset["class_defs"]["offset"], self.dataOffset["class_defs"]["size"])
        print "[+] dex_map_list(0x88) - offset : %x size : %x" % (self.dataOffset["dex_map_list"]["offset"], self.dataOffset["dex_map_list"]["size"])
        print "==== data body ===="
        print "[+] string_items(0x21) - offset : %x size : %x" % (self.dataOffset["string_items"]["offset"], self.dataOffset["string_items"]["size"])
        print "[+] type_item_list(0x41) - offset : %x size : %x" % (self.dataOffset["type_item_list"]["offset"], self.dataOffset["type_item_list"]["size"])
        print "[+] class_data(0x71) - offset : %x size : %x" % (self.dataOffset["class_data"]["offset"], self.dataOffset["class_data"]["size"])
        print "[+] code_item(0x72) - offset : %x size : %x" % (self.dataOffset["code_item"]["offset"], self.dataOffset["code_item"]["size"])
        print "[+] annotation_item(0x73) - offset : %x size : %x" % (self.dataOffset["annotation_item"]["offset"], self.dataOffset["annotation_item"]["size"])
        print "=========================== end =========================="
        print 


    def getStringTable(self):
        """
        문자열 테이블 리턴 
        :return:
        """
        return self.__stringTable

    def getOrigString(self, idx):
        """
        문자열 반환
        :param idx: 
        :return: 
        """
        return self.__stringTable[idx]

    def getString(self, idx):
        if idx in self.__obfTable:
            return self.__obfTable[idx]
        else:
            return self.__stringTable[idx]

    def getTypeId(self, idx):
        return self.__typeList[idx]

    def getName(self):
        """
        dex file name을 반환
        :return::String::filename
        """

        return os.path.basename(self.__dexFilename)

    def isDex(self):
        """
        dex 파일 여부
        :return::boolean::
        """
        sig = self.__fp.read(8)
        self.__fp.seek(0)
        if sig == "\x64\x65\x78\x0A\x30\x33\x35\x00":
            return True
        else:
            return False

    def getClassList(self, _type="id"):
        """
        클래스 리스트 반환
        :param _type: 클래스 리스트 타입 (이름 또는 classId)
        :return:
        """
        if _type == "id":
            return self.__classTable.keys()

    def getMethodCount(self):
        return len(self.__methodTable.keys())

    def getClass(self, id, _type="id"):
        """
        클래스 핸들 반환
        :param id:
        :param _type:
        :return:
        """
        if _type == "id" and id in self.__classTable:
            hClass = self.__classTable[id]
            return hClass
        elif _type == "name" and id in self.__classNameTable:
            hClass = self.__classNameTable[id]
            return hClass
        else:
            return False

    def getFieldTable(self):
        return self.__fieldTable

    def getMethodTable(self):
        return self.__methodTable

    def getField(self, fieldId):
        """
        필드 핸들 반환
        :param fieldId:
        :return:
        """
        if fieldId not in self.__fieldTable:
            util.DPRINT("!", "%x is not in field table!" % fieldId)
            hField = False
        else:
            hField = self.__fieldTable[fieldId]
        return hField

    def getMethod(self, methodId):
        """
        메서드 핸들 반환
        :param methodId:
        :return:
        """
        if methodId not in self.__methodTable:
            util.DPRINT("!", "%x is not in method table!" % methodId)
            hMethod = False
        else:
            hMethod = self.__methodTable[methodId]
        return hMethod

    def createClass(self, name=None):
        """
        클래스 생성
        :return:
        """
        dc = DalvikClass(self)
        classId = len(self.__classTable.keys())
        self.__classTable[classId] = dc
        dc.setInfo(classId, name)
        return dc

    def delClass(self, hClass):
        """
        클래스 삭제
        :param name:
        :return:
        """
        del self.__classTable[hClass.getId()]

    def typeToString(self, typeId, orig=False):
        if orig:
            return_string = self.getString(self.getTypeId(typeId))
            return return_string
        hClass = self.getClass(typeId)
        if hClass is False:
            return_string = self.getString(self.getTypeId(typeId))
        else:
            return_string = hClass.getFullName()

        return return_string
        
    def getProtoList(self):
        return self.__protoList

    def protoToData(self, proto_id):
        """
        proto id 를 문자열로 변환
        :param proto_id:
        :return:
        """
        p = self.__protoList[proto_id]
        # return_string = self.getString(self.__typeList[p.return_type_idx])

        returnString = self.typeToString(p.return_type_idx)

        params = []
        if p.parameters_off != 0:
            self.__fp.seek(p.parameters_off)
            size = self.__fp.read_dword()
            for i in range(size):
                typeIdx = self.__fp.read_word()
                params.append(self.typeToString(typeIdx))
        return returnString, params

    def protoToString(self, proto_id, orig=False):
        """
        proto id 를 문자열로 변환
        :param proto_id:
        :return:
        """

        p = self.__protoList[proto_id]
        # return_string = self.getString(self.__typeList[p.return_type_idx])
        returnString = self.typeToString(p.return_type_idx, orig)

        param_string = ""
        if p.parameters_off != 0:
            self.__fp.seek(p.parameters_off)
            size = self.__fp.read_dword()
            for i in range(size):
                typeIdx = self.__fp.read_word()
                param_string += self.typeToString(typeIdx, orig)

        return returnString, param_string

    def getRandClass(self):
        """
        static method shuffling에 사용될 클래스
        :return:
        """
        if len(self.__classTable.keys()) == 0:
            None

        size = len(self.__classTable.keys())
        # t = random.randint(0, size-1)
        t = agRand.getRand([0, size-1])
        classId = self.__classTable.keys()[t]
        return self.__classTable[classId]

    def getRandPackage(self):
        hClass = self.getRandClass()
        return hClass.getPackage()

    def annotation_to_string(self, annotation_item, depth=0):
        msg = "%s.annotation " % (prefix * depth)
        if hasattr(annotation_item, "visibility"):
            msg += ("%s " % annotation_item.visibility)
        msg += ("%s\n" % self.typeToString(annotation_item.annotation.type_idx))

        for element in annotation_item.annotation.elements:
            msg += ("%s%s = " % (prefix * (depth + 1), self.getString(element.name_idx)))
            msg += "%s\n" % self.annotatioValueToString(element.encoded_value, depth=2)

        msg += "\n%s.end annotation\n" % (prefix * depth)
        
        try:
            return msg.encode("utf-8")
        except:
            return msg

    def annotation_to_data(self, annotation_item, depth=0):
        """
        @TODO: 구조체(class) 로 변경해야함
        :param annotation_item:
        :param depth:
        :return:
        """
        data = {}
        if hasattr(annotation_item, "visibility"):
            data["visibility"] = annotation_item.visibility
        else:
            data["visibility"] = None
        return data

    def annotatioValueToString(self, element, depth=0):
        """
        annotation value
        :param element:
        :param depth: indentation을 위해 사용
        :return:
        """
        msg = ""
        _type = element.value_type
        value = element.value
        # value = element.encoded_value.getValue()

        if _type == VALUE_STRING:
            msg += "\"%s\"" % util.decode(self.getString(value))
        elif _type == VALUE_ENUM:
            msg += ("%s " % VALUE_TYPE_STR[element.value_type])
            msg += self.getField(value).getFullName("method")   # self.fieldToString(value, "method")
        elif _type == VALUE_ARRAY:
            msg += "{\n"
            for i in value:
                msg += "%s%s" % (prefix * (depth + 1), self.annotatioValueToString(i))
                if value[-1] != i:
                    msg += ","
                msg += "\n"
            msg += "%s}" % (prefix * depth)
        elif _type == VALUE_BYTE:
            if value > 0x7F:
                msg += "%st" % hex(value - 0x100)
            else:
                msg += "%st" % hex(value)
        elif _type == VALUE_SHORT:
            if element.value_arg == 0:
                if value > 0x7F:
                    msg += "%ss" % hex(value - 0x100)
                else:
                    msg += "%ss" % hex(value)
            else:
                if value > 0x7FFF:
                    msg += "%ss" % hex(value - 0x10000)
                else:
                    msg += "%ss" % hex(value)

        # TODO 코드 정리 필요
        elif _type == VALUE_INT:
            if element.value_arg == 0:
                if value > 0x7F:
                    msg += "%s" % hex(value - 0x100)
                else:
                    msg += "%s" % hex(value)
            elif element.value_arg == 1:
                if value > 0x7FFF:
                    msg += "%s" % hex(value - 0x10000)
                else:
                    msg += "%s" % hex(value)
            elif element.value_arg == 2:
                if value > 0x7FFFFF:
                    msg += "%s" % hex(value - 0x1000000)
                else:
                    msg += "%s" % hex(value)

            else:
                if value > 0x7FFFFFFF:
                    result = value - 0x100000000
                    msg += "%s" % hex(int(result))
                else:
                    msg += "%s" % hex(value)

        elif _type == VALUE_LONG:
            if element.value_arg == 0:
                if value > 0x7F:
                    msg += "%s" % hex(long(value - 0x100))
                else:
                    msg += "%s" % hex(long(value))

            elif element.value_arg == 1:
                if value > 0x7FFF:
                    msg += "%s" % hex(long(value - 0x10000))
                else:
                    msg += "%s" % hex(long(value))

            elif element.value_arg == 2:
                if value > 0x7FFFFF:
                    msg += "%s" % hex(long(value - 0x1000000))
                else:
                    msg += "%s" % hex(long(value))

            elif element.value_arg == 3:
                if value > 0x7FFFFFFF:
                    msg += "%s" % hex(long(value - 0x100000000))
                else:
                    msg += "%s" % hex(long(value))

            elif element.value_arg == 4:
                if value > 0x7FFFFFFFFF:
                    msg += "%s" % hex(long(value - 0x10000000000))
                else:
                    msg += "%s" % hex(long(value))

            elif element.value_arg == 5:
                if value > 0x7FFFFFFFFFFF:
                    msg += "%s" % hex(long(value - 0x1000000000000))
                else:
                    msg += "%s" % hex(long(value))
            elif element.value_arg == 6:
                if value > 0x7FFFFFFFFFFFFF:
                    msg += "%s" % hex(long(value - 0x100000000000000))
                else:
                    msg += "%s" % hex(long(value))
            else:
                if value > 0x7FFFFFFFFFFFFFFF:
                    msg += "%s" % hex(value - 0x10000000000000000)
                else:
                    msg += "%s" % hex(long(value))

        elif _type == VALUE_CHAR:
            msg += "\'\\u%04x\'" % value

        # TODO 코드 정리 필요
        elif _type == VALUE_FLOAT:
            if float(value) == float("-inf"):
                msg += "-Infinityf"
            elif float(value) == float("inf"):
                msg += "Infinityf"
            else:
                r = "%s" % float(value)
                if "e+" in r:
                    f = round(float(r.split("e+")[0]), 9)
                    msg += "%sE%s" % (f, r.split("e+")[1])
                elif "e-" in r:
                    f = float(r.split("e-")[0])
                    msg += "%sE-%s" % (f, int(r.split("e-")[1]))

                else:
                    msg += "{0:.9f}".format(value)

                if _type == VALUE_FLOAT:
                    msg += "f"

        elif _type == VALUE_DOUBLE:
            if float(value) == float("-inf"):
                msg += "-Infinity"
            elif float(value) == float("inf"):
                msg += "Infinity"
            else:
                r = "%s" % value.__repr__()

                if "e+" in r:
                    msg += "%sE%s" % (r.split("e+")[0], r.split("e+")[1])
                elif "e-" in r:
                    msg += "%sE-%s" % (r.split("e-")[0], int(r.split("e-")[1]))

                else:
                    msg += "{0:.9f}".format(value)

        elif _type == VALUE_NULL:
            msg += "null"
        elif _type == VALUE_TYPE:
            msg += "%s" % self.getString(self.getTypeId(value))     # self.typeToString(value)
        elif _type == VALUE_METHOD:
            msg += "%s" % self.getMethod(value).getFullName("method")   # self.methodToString(value, "method")

        elif _type == VALUE_ANNOTATION:
            msg += ".subannotation %s\n" % (self.getString(self.getTypeId(value.type_idx)))
            for element in value.elements:
                msg += ("%s%s = " % (prefix * (depth + 1), util.decode(self.getString(element.name_idx))))
                msg += "%s\n" % self.annotatioValueToString(element.encoded_value, depth=depth + 1)
            msg += "%s.end subannotation" % (prefix * depth)
        elif _type == VALUE_BOOLEAN:
            msg += "%s" % value
        else:
            print "T", _type

        return msg
