# -*- coding:utf-8 -*-
TYPE_NOTUSED = 0
TYPE_REG = 0x01
TYPE_CONST = 0x02
TYPE_STRING = 0x03
TYPE_GOTO = 0x04
TYPE_SPARSE = 0x05  # switch
TYPE_CONDITION = 0x06
TYPE_ARRAY = 0x07
TYPE_TYPE = 0x08
TYPE_FIELD = 0x09
TYPE_OPERAND_LIST = 0x10
TYPE_METHOD = 0x11
TYPE_CATCH = 0x12
TYPE_CATCHALL = 0x13
TYPE_TRY_START = 0x14
TYPE_TRY_END = 0x15
TYPE_OPERAND_RANGE = 0x16
TYPE_SSWITCH = 0x17
TYPE_PSWITCH = 0x18

opcode_size = [ \
            # 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
            2, 2, 4, 6, 2, 4, 6, 2, 4, 6, 2, 2, 2, 2, 2, 2,  # 0
            2, 2, 2, 4, 6, 4, 4, 6, 10, 4, 4, 6, 4, 2, 2, 4,  # 1
            4, 2, 4, 4, 6, 6, 6, 2, 2, 4, 2, 6, 6, 4, 4, 4,  # 2
            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2,  # 3
            2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,  # 4
            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,  # 5
            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6, 6,  # 6
            6, 6, 6, 2, 6, 6, 6, 6, 6, 2, 2, 2, 2, 2, 2, 2,  # 7
            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,  # 8
            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,  # 9
            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,  # A
            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,  # B
            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,  # C
            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,  # D
            4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 2,  # E
            6, 2, 4, 4, 4, 4, 4, 4, 6, 6, 6, 6, 2, 2, 2, 2,  # F
        ]

VALUE_TYPE_STR = {
    0x00: "",
    0x02: "",
    0x03: "",
    0x04: "",
    0x06: "",
    0x10: "",
    0x11: "",
    0x17: "",
    0x18: ".type",
    0x19: ".field",
    0x1a: ".method",
    0x1b: ".enum",
    0x1c: ".array",
    0x1d: ".subannotation",
    0x1e: ".nulll",
    0x1f: ".boolean",

}

VALUE_BYTE = 0x00
VALUE_SHORT = 0x02
VALUE_CHAR = 0x03
VALUE_INT = 0x04
VALUE_LONG = 0x06
VALUE_FLOAT = 0x10
VALUE_DOUBLE = 0x11
VALUE_STRING = 0x17
VALUE_TYPE = 0x18
VALUE_FIELD = 0x19
VALUE_METHOD = 0x1a
VALUE_ENUM = 0x1b
VALUE_ARRAY = 0x1c
VALUE_ANNOTATION = 0x1d
VALUE_NULL = 0x1e
VALUE_BOOLEAN = 0x1f


def flags2string(access_flags, _type="field"):
    s2 = ''  # 플래그
    if access_flags & 0x01 == 0x01:  # ACC_PUBLIC
        s2 += 'public '
        access_flags &= 0xFFFFFFFE
    if access_flags & 0x02 == 0x02:  # ACC_PRIVATE
        s2 += 'private '
        access_flags &= 0xFFFFFFFD
    if access_flags & 0x04 == 0x04:  # ACC_PROTECTED
        s2 += 'protected '
        access_flags &= 0xFFFFFFFB
    if access_flags & 0x08 == 0x08:  # ACC_STATIC
        s2 += 'static '
        access_flags &= 0xFFFFFFF7
    if access_flags & 0x10 == 0x10:  # ACC_FINAL
        s2 += 'final '
        access_flags &= 0xFFFFFFEF
    if access_flags & 0x20 == 0x20:  # ACC_SYNCHRONIZED
        s2 += 'synchronized '
        access_flags &= 0xFFFFFFDF
    if access_flags & 0x40 == 0x40:  # ACC_VOLATILE
        if _type == "field":
            s2 += 'volatile '
        else:
            s2 += 'bridge '
        access_flags &= 0xFFFFFFBF
    if access_flags & 0x80 == 0x80:  # ACC_TRANSIENT
        s2 += 'transient '
        access_flags &= 0xFFFFFF7F
    if access_flags & 0x100 == 0x100:  # ACC_NATIVE
        s2 += 'native '
        access_flags &= 0xFFFFFEFF
    if access_flags & 0x200 == 0x200:  # ACC_INTERFACE
        s2 += 'interface '
        access_flags &= 0xFFFFFDFF
    if access_flags & 0x400 == 0x400:  # ACC_ABSTRACT
        s2 += 'abstract '
        access_flags &= 0xFFFFFBFF
    if access_flags & 0x800 == 0x800:  # ACC_STRICT
        s2 += 'strict '
        access_flags &= 0xFFFFF7FF
    if access_flags & 0x1000 == 0x1000:  # ACC_SYNTHETIC
        s2 += 'synthetic '
        access_flags &= 0xFFFFEFFF
    if access_flags & 0x2000 == 0x2000:  # ACC_ANNOTATION
        s2 += 'annotation '
        access_flags &= 0xFFFFDFFF
    if access_flags & 0x4000 == 0x4000:  # ACC_ANNOTATION
        s2 += 'enum '
        access_flags &= 0xFFFFBFFF
    if access_flags & 0x10000 == 0x10000:  # ACC_CONSTRUCTOR
        s2 += 'constructor '
        access_flags &= 0xFFFEFFFF
    if access_flags & 0x20000 == 0x20000:  # ACC_DECLARED_SYNCHRONIZED
        s2 += 'declared-synchronized '
        access_flags &= 0xFFFDFFFF

    if access_flags:
        s2 += '=====> %x ' % access_flags

    return s2.strip()


class DalvikClass:
    def __init__(self):
        self.classIdx = None
        self.smaliPath = None
        self.packageName = ".class %s"
        self.classString = ".class %s %s"
        self.name = None
        self.accessFlag = None
        self.super = ".super %s"
        self.source = ".source \"%s\""
        self.staticFields = None
        self.instanceFields = None
        self.virtualMethods = []
        self.directMethods = []
        self.annotation = []
        self.implement = None
        self.code = None
        self.new = False

        self.parent = None  # 부모 클래스
        self.methodNameList = []


class DalvikMethod:
    def __init__(self):
        self.className = None
        self.nRegisters = 0
        self.nParameters = 0
        self.Annotation = []
        self.Instructions = []
        self.ArrayCount = 0
        self.name = ""
        self.try_catch = [[], [], []]
        self.payload = []
        self.payload_table = {}
        self.encStrings = []
        self.text = None
        self.flag = None
        self.params = []


class DalvikInstruction:
    def __init__(self):
        self.text = ""
        self.Opcode = ""
        self.Operand1 = ""
        self.Operand2 = ""
        self.Operand3 = ""
        self.origText = ""
        self.pc = 0
        self._pass = False
        self.label = []
        self.label_end = []
        self.branchLabel = None
        self.isLast = False

    def toString(self):
        if self.branchLabel is None:
            return self.text
        else:   # 임시로....
            self.text = self.text.split(":")[0] + self.branchLabel.toString()
            return self.text


class DalvikField:
    def __init__(self):
        self.text = ""
        self.fieldName = ""
        self.proto = ""
        self.accessFlag = ""
        self.fieldIdx = ""
        self.fieldValue = None

'''
class CATCH:
    def __init__(self):
        self.exceptionType = None
        self.try_start = None
        self.try_end = None
        self.catch = None
        self.type = None

    def toString(self):
        if self.type == TYPE_CATCH:
            return ".catch %s {%s .. %s} %s" % (self.exceptionType, self.try_start.toString(),
                                                self.try_end.toString(), self.catch.toString())

        elif self.type == TYPE_CATCHALL:
            return ".catchall {%s .. %s} %s" % (self.try_start.toString(), self.try_end.toString(),
                                                self.catch.toString())

'''
class LABEL:
    def __init__(self):
        self.off = None
        self.type = None
        self.data = []
        self.appendString = ""  # 라벨 중복을 막기 위해 추가하는 문자열
        self.catchLabel = []  # try_end 에서만 사용

    def toString(self):
        if self.type == TYPE_CONDITION:
            return ":cond_%x%s" % (self.off, self.appendString)
        elif self.type == TYPE_GOTO:
            return ":goto_%x%s" % (self.off, self.appendString)
        elif self.type == TYPE_CATCH:
            return ":catch_%x%s" % (self.off, self.appendString)
        elif self.type == TYPE_CATCHALL:
            return ":catchall_%x%s" % (self.off, self.appendString)
        elif self.type == TYPE_TRY_START:
            return ":try_start_%x%s" % (self.off, self.appendString)
        elif self.type == TYPE_TRY_END:
            return ":try_end_%x%s" % (self.off, self.appendString)
        elif self.type == TYPE_PSWITCH:
            return ":pswitch_%x%s" % (self.off, self.appendString)
        elif self.type == TYPE_SSWITCH:
            return ":sswitch_%x%s" % (self.off, self.appendString)

    def toData(self):
        None


class LABEL_TABLE:
    """
    라벨 테이블
    """
    def __init__(self):
        self.goto_label = {}
        self.sparse_label = {}
        self.cond_label = {}
        self.catch_label = {}
        self.catch_all_label = {}
        self.try_start_label = {}
        self.try_end_label = {}
        self.packed_label = {}

    def append(self, label):
        if label.type == TYPE_GOTO:
            if label.off not in self.goto_label:
                self.goto_label[label.off] = label

        elif label.type == TYPE_PSWITCH:
            if label.off not in self.packed_label:
                self.packed_label[label.off] = label

        elif label.type == TYPE_SSWITCH:
            if label.off not in self.sparse_label:
                self.sparse_label[label.off] = label

        elif label.type == TYPE_CONDITION:
            if label.off not in self.cond_label:
                self.cond_label[label.off] = label

        elif label.type == TYPE_CATCH:
            if label.off not in self.catch_label:
                self.catch_label[label.off] = label

        elif label.type == TYPE_CATCHALL:
            if label.off not in self.catch_all_label:
                self.catch_all_label[label.off] = label

        elif label.type == TYPE_TRY_START:
            if label.off not in self.try_start_label:
                self.try_start_label[label.off] = label

        elif label.type == TYPE_TRY_END:
            if label.off not in self.try_end_label:
                self.try_end_label[label.off] = label

    def getLabel(self, off, _type):
        labels = []
        if _type == TYPE_GOTO or _type == "front" or _type == "all":
            if off in self.goto_label:
                labels.append(self.goto_label[off])

        if _type == TYPE_PSWITCH or _type == "front" or _type == "all":
            if off in self.packed_label:
                labels.append(self.packed_label[off])

        if _type == TYPE_SSWITCH or _type == "front" or _type == "all":
            if off in self.sparse_label:
                labels.append(self.sparse_label[off])

        if _type == TYPE_CONDITION or _type == "front" or _type == "all":
            if off in self.cond_label:
                labels.append(self.cond_label[off])

        if _type == TYPE_CATCH or _type == "front" or _type == "all":
            if off in self.catch_label:
                labels.append(self.catch_label[off])

        if _type == TYPE_CATCHALL or _type == "front" or _type == "all":
            if off in self.catch_all_label:
                labels.append(self.catch_all_label[off])

        if _type == TYPE_TRY_START or _type == "front" or _type == "all":
            if off in self.try_start_label:
                labels.append(self.try_start_label[off])

        if _type == TYPE_TRY_END or _type == "end" or _type == "all":
            if off in self.try_end_label:
                labels.append(self.try_end_label[off])

        return labels

    def freeLabel(self, off, _type):
        if _type == TYPE_GOTO or _type == "front" or _type == "all":
            if off in self.goto_label:
                del self.goto_label[off]

        if _type == TYPE_SPARSE or _type == "front" or _type == "all":
            if off in self.sparse_label:
                del self.sparse_label[off]

        if _type == TYPE_CONDITION or _type == "front" or _type == "all":
            if off in self.cond_label:
                del self.cond_label[off]

        if _type == TYPE_CATCH or _type == "front" or _type == "all":
            if off in self.catch_label:
                del self.catch_label[off]

        if _type == TYPE_CATCHALL or _type == "front" or _type == "all":
            if off in self.catch_all_label:
                del self.catch_all_label[off]

        if _type == TYPE_TRY_START or _type == "front" or _type == "all":
            if off in self.try_start_label:
                del self.try_start_label[off]

        if _type == TYPE_SSWITCH or _type == "front" or _type == "all":
            if off in self.sparse_label:
                del self.sparse_label[off]

        if _type == TYPE_PSWITCH or _type == "front" or _type == "all":
            if off in self.packed_label:
                del self.packed_label[off]

        if _type == TYPE_TRY_END or _type == "end" or _type == "all":
            if off in self.try_end_label:
                del self.try_end_label[off]

    def changeLabel(self, off):
        """
        라벨 변경 - method 머지 하는 경우 라벨 겹침이 발생할 수 있으므로 변경해줘야함
        :param off:
        :return:
        """
        for idx in self.goto_label:
            self.goto_label[idx].off += off
        for idx in self.sparse_label:
            self.sparse_label[idx].off += off
        for idx in self.cond_label:
            self.cond_label[idx].off += off
        for idx in self.catch_label:
            self.catch_label[idx].off += off
        for idx in self.catch_all_label:
            self.catch_all_label[idx].off += off
        for idx in self.try_start_label:
            self.try_start_label[idx].off += off
        for idx in self.try_end_label:
            self.try_end_label[idx].off += off


class NotSupport(Exception):
    None

class CacthAll:
    def __init__(self):
        self.try_start = None
        self.try_end = None
        self.catch_all = None
        self.off = None
        self.type = None
        self._type = None

    def toString(self):
        return "\n    .catchall {%s .. %s} %s" % \
               (self.try_start.toString(), self.try_end.toString(), self.catch_all.toString())


class Catch:
    def __init__(self):
        self.try_start = None
        self.try_end = None
        self.catch = None
        self.off = None
        self._type = None

    def toString(self):
        return "\n    .catch %s {%s .. %s} %s" % (self._type, self.try_start.toString(),
                                                         self.try_end.toString(), self.catch.toString())


prefix = "    "