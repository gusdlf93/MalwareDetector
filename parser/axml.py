# -*- coding: utf-8 -*-
import struct
import mmap 
from collections import defaultdict
from struct import pack, unpack

LITTLE_ENDIAN = '<'
BIG_ENDIAN = '>'


TYPE_NULL = 0
TYPE_REFERENCE = 1
TYPE_ATTRIBUTE = 2
TYPE_STRING = 3
TYPE_FLOAT = 4
TYPE_DIMENSION = 5
TYPE_FRACTION = 6
TYPE_FIRST_INT = 16
TYPE_INT_DEC = 16
TYPE_INT_HEX = 17
TYPE_INT_BOOLEAN = 18
TYPE_FIRST_COLOR_INT = 28
TYPE_INT_COLOR_ARGB8 = 28
TYPE_INT_COLOR_RGB8 = 29
TYPE_INT_COLOR_ARGB4 = 30
TYPE_INT_COLOR_RGB4 = 31
TYPE_LAST_COLOR_INT = 31
TYPE_LAST_INT = 31


class NRFile:
    def __init__(self, mm):
        self.mm = mm
        self.off = 0
        if type(mm) == str:
            self.size = len(mm)
        else:
            self.size = mm.size()
         
    def get_size(self):
        return self.size
        
    def seek(self, off):
        self.off = off
        
    def read(self, size):
        data = self.mm[self.off:self.off + size]
        self.off += size
        return data

    def get_byte(self):
        data = ord(self.mm[self.off])
        self.off += 1
        return data
        
    def get_uint16(self, _endian=LITTLE_ENDIAN):
        data = struct.unpack(_endian + 'H', self.mm[self.off:self.off+2])[0]
        self.off += 2
        return data
        
    def get_uint32(self, _endian=LITTLE_ENDIAN):
        data = struct.unpack(_endian + 'L', self.mm[self.off:self.off+4])[0]
        self.off += 4
        return data
        
    def get_uint64(self, _endian=LITTLE_ENDIAN):
        data = struct.unpack(_endian + 'Q', self.mm[self.off:self.off+8])[0]
        self.off += 8
        return data    
        
    def tell(self):
        return self.off
        
        
RADIX_MULTS = [0.00390625, 3.051758E-005, 1.192093E-007, 4.656613E-010]
DIMENSION_UNITS = ["px", "dip", "sp", "pt", "in", "mm"]
FRACTION_UNITS = ["%", "%p"]

COMPLEX_UNIT_MASK = 15


def complexToFloat(xcomplex):
    return float(xcomplex & 0xFFFFFF00) * RADIX_MULTS[(xcomplex >> 4) & 3]


def long2int(l):
    if l > 0x7fffffff:
        l = (0x7fffffff & l) - 0x80000000
    return l


def long2str(l):
    """Convert an integer to a string."""
    if type(l) not in (types.IntType, types.LongType):
        raise ValueError('the input must be an integer')

    if l < 0:
        raise ValueError('the input must be greater than 0')
    s = ''
    while l:
        s = s + chr(l & 255)
        l >>= 8

    return s


def str2long(s):
    """Convert a string to a long integer."""
    if type(s) not in (types.StringType, types.UnicodeType):
        raise ValueError('the input must be a string')

    l = 0
    for i in s:
        l <<= 8
        l |= ord(i)

    return l


def getPackage(i):
    if i >> 24 == 1:
        return "android:"
    return ""


def format_value(_type, _data, lookup_string=lambda ix: "<string>"):
    if _type == TYPE_STRING:
        return lookup_string(_data)

    elif _type == TYPE_ATTRIBUTE:
        return "?%s%08X" % (getPackage(_data), _data)

    elif _type == TYPE_REFERENCE:
        return "@%s%08X" % (getPackage(_data), _data)

    elif _type == TYPE_FLOAT:
        return "%f" % unpack("=f", pack("=L", _data))[0]

    elif _type == TYPE_INT_HEX:
        return "0x%08X" % _data

    elif _type == TYPE_INT_BOOLEAN:
        if _data == 0:
            return "false"
        return "true"

    elif _type == TYPE_DIMENSION:
        return "%f%s" % (complexToFloat(_data), DIMENSION_UNITS[_data & COMPLEX_UNIT_MASK])

    elif _type == TYPE_FRACTION:
        return "%f%s" % (complexToFloat(_data) * 100, FRACTION_UNITS[_data & COMPLEX_UNIT_MASK])

    elif TYPE_FIRST_COLOR_INT <= _type <= TYPE_LAST_COLOR_INT:
        return "#%08X" % _data

    elif TYPE_FIRST_INT <= _type <= TYPE_LAST_INT:
        return "%d" % long2int(_data)

    return "<0x%X, type 0x%02X>" % (_data, _type)
    
        
class ARSCHeader(object):
    SIZE = 2 + 2 + 4

    def __init__(self, handle):
        self.start = handle.tell()
        self.type = handle.get_uint16()
        self.header_size = handle.get_uint16()
        self.size = handle.get_uint32()

    def __repr__(self):
        return "<ARSCHeader idx='0x{:08x}' type='{}' header_size='{}' size='{}'>".format(self.start, self.type, self.header_size, self.size)        


UTF8_FLAG = 1 << 8


class StringBlock:
    def __init__(self, handle, header):
        self.m_strings = []
        self.handle = handle
        self.header = header
        
        self.stringCount = handle.get_uint32()
        self.styleOffsetCount = handle.get_uint32()
        
        self.flags = handle.get_uint32()
        self.m_isUTF8 = ((self.flags & UTF8_FLAG) != 0)

        self.stringsOffset = handle.get_uint32()
        self.stylesOffset = handle.get_uint32()
        
        # 스타일 오프셋 카운트가 0인데 스타일 오프셋이 존재하는 경우 
        if self.styleOffsetCount == 0 and self.stylesOffset > 0:
            print "[-] Warning styleOffsetCount is 0 "
        
        self.m_stringOffsets = []
        self.m_styleOffsets = []
        self.m_charbuff = ""
        self.m_styles = []
        
        for i in range(self.stringCount):
            self.m_stringOffsets.append(handle.get_uint32())
            
        for i in range(self.styleOffsetCount):
            self.m_styleOffsets.append(handle.get_uint32())
        
        size = self.header.size - self.stringsOffset
        
        if self.stylesOffset != 0 and self.styleOffsetCount != 0:
            size = self.stylesOffset - self.stringsOffset
        
        self.m_charbuff = NRFile(handle.read(size))   
        
        for off in self.m_stringOffsets:
            if self.m_isUTF8:
                self.m_strings.append(self.decode8(off).replace("\x00", ""))
            else:
                self.m_strings.append(self.decode16(off).replace("\x00", ""))
        
    def decode8(self, off):
        self.m_charbuff.seek(off)
        size = self.m_charbuff.get_byte()
        size = self.m_charbuff.get_byte()
        strlen = (size + 1)
        data = self.m_charbuff.read(strlen)
        return data
        
    def decode16(self, off):
        self.m_charbuff.seek(off)
        size = self.m_charbuff.get_uint16()
        strlen = (size + 1) * 2
        data = self.m_charbuff.read(strlen)
        return data[::2]
        
    def get_string(self, idx):
        pos = self.m_strings[idx].find("\x00")
        if pos > 0:
            return self.m_strings[idx][:pos]
        else:
            return self.m_strings[idx]
        

# Chunk Headers
CHUNK_AXML_FILE = 0x00080003
CHUNK_STRING = 0x001C0001
CHUNK_RESOURCEIDS = 0x00080180
CHUNK_XML_FIRST = 0x00100100
CHUNK_XML_START_NAMESPACE = 0x00100100
CHUNK_XML_END_NAMESPACE = 0x00100101
CHUNK_XML_START_TAG = 0x00100102
CHUNK_XML_END_TAG = 0x00100103
CHUNK_XML_TEXT = 0x00100104
CHUNK_XML_LAST = 0x00100104

# Position of the fields inside an attribute
ATTRIBUTE_IX_NAMESPACE_URI = 0
ATTRIBUTE_IX_NAME = 1
ATTRIBUTE_IX_VALUE_STRING = 2
ATTRIBUTE_IX_VALUE_TYPE = 3
ATTRIBUTE_IX_VALUE_DATA = 4
ATTRIBUTE_LENGTH = 5


class AXMLParser(object):
    def __init__(self, mm):
        # 파일 핸들 
        self.aHandle = NRFile(mm)
        
        # AXML 파일 체크 
        chunk_type = self.aHandle.get_uint32()
        if chunk_type != CHUNK_AXML_FILE:
            # 일부로 최초 chunktype을 훼손시키는 경우 존재함 
            if chunk_type >> 16 == 0x0008:
                None
            else:
                return False

        # AXML 파일 크기 
        self.filesize = self.aHandle.get_uint32()
        
        # 리소스 해더 
        header = ARSCHeader(self.aHandle) # read 8 byte = String header + chunk_size
        # 문자열 블록 분석 
        self.sb = StringBlock(self.aHandle, header)

        self.m_resourceIDs = []     # 리소스 ID
        self.m_prefixuri = {}       # uri prefix
        self.m_uriprefix = defaultdict(list)    # ?
        self.m_prefixuriL = []      # ?
        self.visited_ns = []        # ?
        self.tagNameList = []
        
        self.uer_permission = []
        self.app_info = {}
        self.filter_flag = False
        self.activity = []
        self.receiver = []
        self.service = []
        self.provider = []
        self.application = None
        self.temp = {}
        self.atemp = {}
        self.onClick = []

    def getPrefix(self, printable=True):
        if self.m_namespaceUri == 0xFFFFFFFF:
            return u''

        # FIXME this could be problematic. Need to find the correct namespace prefix
        if self.m_namespaceUri in self.m_uriprefix:
            candidate = self.m_uriprefix[self.m_namespaceUri][0]
            try:
                if printable:
                    return self.sb.get_string(candidate) + u':'
                else:
                    return self.sb.get_string(candidate)
            except KeyError:
                return u''
        else:
            return u''
            
    def getPrefixByUri(self, uri):
        # As uri --> prefix is 1:n mapping,
        # We will just return the first one we match.
        if uri not in self.m_uriprefix:
            return -1
        else:
            if len(self.m_uriprefix[uri]) == 0:
                return -1
            return self.m_uriprefix[uri][0]
            
    def getAttributeOffset(self, index):
        offset = index * 5
        return offset
        
    def getAttributePrefix(self, index):
        offset = self.getAttributeOffset(index)
        uri = self.m_attributes[offset + ATTRIBUTE_IX_NAMESPACE_URI]

        prefix = self.getPrefixByUri(uri)

        if prefix == -1:
            return ""

        return self.sb.get_string(prefix)

    def _getAttributeValue(self, index):
        offset = self.getAttributeOffset(index)
        valueType = self.m_attributes[offset + ATTRIBUTE_IX_VALUE_TYPE]
        if valueType == TYPE_STRING:
            valueString = self.m_attributes[offset + ATTRIBUTE_IX_VALUE_STRING]
            return self.sb.get_string(valueString)
        return ""
        
    def getAttributeValue(self, index):
        offset = self.getAttributeOffset(index)
        _type = self.m_attributes[offset + ATTRIBUTE_IX_VALUE_TYPE]
        _data = self.m_attributes[offset + ATTRIBUTE_IX_VALUE_DATA]
       
        return format_value(_type, _data, lambda _: self._getAttributeValue(index))
        
    def getAttributeName(self, index):
        offset = self.getAttributeOffset(index)
        name = self.m_attributes[offset + ATTRIBUTE_IX_NAME]
        if name == -1:
            return ""
            
        attr_name = self.sb.get_string(name)
        if not attr_name:
            attr = self.m_resourceIDs[name]
            attr_name = 'android:UNKNOWN_SYSTEM_ATTRIBUTE_{:08x}'.format(attr)
        return attr_name
        
    def parse(self):
        buff = ""
        while True:
            self.m_attributes = []
            # 파일 오프셋이 파일 끝까지 간 경우 
            if self.aHandle.tell() >= self.aHandle.get_size():
                break

            chunk_type = self.aHandle.get_uint32()
            
            # 리소스 ID
            if chunk_type == CHUNK_RESOURCEIDS:
                chunk_size = self.aHandle.get_uint32()
                
                if chunk_size < 8 or chunk_size % 4 != 0:
                    print ("[-] Invalid chunk size in chunk RESOURCEIDS")
                    
                for i in range((chunk_size // 4) - 2):
                    self.m_resourceIDs.append(self.aHandle.get_uint32())
                continue
                
            # tag 의 끝     
            if chunk_type == CHUNK_XML_END_TAG:
                None
                
            self.aHandle.get_uint32()
            self.m_lineNumber = self.aHandle.get_uint32()
            self.aHandle.get_uint32()    
            
            # XML 네임 스페이스 시작 또는 끝     
            if chunk_type == CHUNK_XML_START_NAMESPACE or chunk_type == CHUNK_XML_END_NAMESPACE:
                # 네임 스페이스 시작 
                if chunk_type == CHUNK_XML_START_NAMESPACE:
                    prefix = self.aHandle.get_uint32()
                    uri = self.aHandle.get_uint32()
                    self.m_prefixuri[prefix] = uri          # 한개의 prefix 는 하나의 uri를 가짐 
                    self.m_uriprefix[uri].append(prefix)    # uri에 prefix 추가, 한개의 uri는 다수의 prefix를 가질수있음 
                    
                # 네임 스페이스 끝 
                else:
                    prefix = self.aHandle.get_uint32()
                    uri = self.aHandle.get_uint32()
                continue
                
            # 태그 시작     
            if chunk_type == CHUNK_XML_START_TAG:
                self.m_namespaceUri = self.aHandle.get_uint32() 
                self.m_name = self.aHandle.get_uint32()
                tag_prefix = self.getPrefix()
                tag_name = self.sb.get_string(self.m_name)
                if tag_name not in self.tagNameList:
                    self.tagNameList.append(tag_name)

                # buff += u'<' + tag_prefix + tag_name + u'\n'
                
                # FIXME
                self.aHandle.get_uint32()  # flags

                attributeCount = self.aHandle.get_uint32()
                
                self.m_idAttribute = (attributeCount >> 16) - 1
                attributeCount = attributeCount & 0xFFFF
                self.m_classAttribute = self.aHandle.get_uint32()
                
                for i in range(attributeCount * ATTRIBUTE_LENGTH):
                    # Each field is linearly parsed into the array
                    self.m_attributes.append(self.aHandle.get_uint32())

                # Then there are class_attributes
                for i in range(ATTRIBUTE_IX_VALUE_TYPE, len(self.m_attributes), ATTRIBUTE_LENGTH):
                    self.m_attributes[i] = self.m_attributes[i] >> 24

                # print "[Tag]", tag_name, len(tag_name)
                
                for i in range(attributeCount):
                    attr_prefix = self.getAttributePrefix(i)
                    attr_name = self.getAttributeName(i)
                    attr_value = self.getAttributeValue(i)

                    if attr_value not in self.tagNameList:
                        self.tagNameList.append(attr_value)
                        
                    # 퍼미션 정보 추가 
                    if tag_name == "uses-permission":
                        self.uer_permission.append(attr_value)
                    
                    elif tag_name == "manifest" or tag_name == "uses-sdk":
                        self.app_info[attr_name] = attr_value
                        
                    elif tag_name == u"activity":
                        self.filter_flag = True
                        self.temp[attr_name] = attr_value
                        self.temp["intent-filter"] = []

                    elif tag_name == u"application":
                        self.atemp[attr_name] = attr_value

                    elif tag_name == "service":
                        self.filter_flag = True
                        self.temp[attr_name] = attr_value
                        self.temp["intent-filter"] = []
                        
                    elif tag_name == "receiver":
                        self.filter_flag = True
                        self.temp[attr_name] = attr_value
                        self.temp["intent-filter"] = []

                    elif tag_name == "provider":
                        self.filter_flag = True
                        self.temp[attr_name] = attr_value
                    
                    elif tag_name == "meta-data":   # todo
                        # self.temp[attr_name] = attr_value
                        None 
                        
                    else:
                        if self.filter_flag:
                            if attr_name != "":
                                self.temp["intent-filter"].append([tag_name, attr_value])
                        if "onClick" in attr_name:
                            self.onClick.append(attr_value)
                
            if chunk_type == CHUNK_XML_END_TAG:
                self.m_namespaceUri = self.aHandle.get_uint32()
                self.m_name = self.aHandle.get_uint32()
                tag_name = self.sb.get_string(self.m_name)

                if tag_name == "activity":
                    self.activity.append(self.temp)
                    self.filter_flag = False
                    self.temp = {}
                if tag_name == "receiver":
                    self.receiver.append(self.temp)
                    self.filter_flag = False
                    self.temp = {}
                if tag_name == "service":
                    self.service.append(self.temp)
                    self.filter_flag = False
                    self.temp = {}
                if tag_name == "provider":
                    self.provider.append(self.temp)
                    self.filter_flag = False
                    self.temp = {}
                if tag_name == "application":
                    self.application = self.atemp
                    self.filter_flag = False
                    self.temp = {}

            if chunk_type == CHUNK_XML_TEXT:
                self.m_name = self.aHandle.get_uint32()
                self.aHandle.get_uint32()
                self.aHandle.get_uint32()
                

if __name__ == "__main__":        
    import sys
    fp = open(sys.argv[1], "rb")        
    mm = mmap.mmap(fp.fileno(), 0, access=mmap.ACCESS_READ)    
    a = AXMLParser(mm)
    a.parse()
    
    print a.activity
    print a.uer_permission
    print a.receiver
    print a.app_info

    print len(a.activity[0]["intent-filter"])
    print len(a.uer_permission)
    print len(a.receiver)
    print len(a.service)
    
    # for i in a.activity:
    #    print i
    # makexml(a)
